<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Quadcopter 1D PID Simulator with 3D Model</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #f9fafb;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }

    h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.04em;
    }

    .container {
      max-width: 1200px;
      width: 100%;
      display: grid;
      grid-template-columns: 3fr 2fr;
      gap: 16px;
    }

    .panel {
      background: rgba(15, 23, 42, 0.96);
      border-radius: 16px;
      padding: 16px 18px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .panel h2 {
      margin: 0 0 10px;
      font-size: 16px;
      font-weight: 600;
      color: #e5e7eb;
    }

    canvas {
      border-radius: 12px;
      background: #020617;
      border: 1px solid rgba(30, 64, 175, 0.7);
    }

    .plot-label {
      font-size: 12px;
      color: #9ca3af;
      margin-bottom: 4px;
    }

    .small-row {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: #6b7280;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .slider-row {
      display: grid;
      grid-template-columns: 70px 1fr 60px;
      gap: 8px;
      align-items: center;
      font-size: 13px;
    }

    input[type="range"] {
      width: 100%;
    }

    .small-label {
      font-size: 11px;
      color: #9ca3af;
    }

    .field-row {
      display: grid;
      grid-template-columns: 110px 1fr;
      gap: 8px;
      align-items: center;
      font-size: 13px;
    }

    input[type="number"], select {
      width: 100%;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: #020617;
      color: #e5e7eb;
      outline: none;
      font-size: 13px;
    }

    input[type="number"]:focus, select:focus {
      border-color: #60a5fa;
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.6);
    }

    .btn-row {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 6px 14px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      background: #1d4ed8;
      color: white;
      box-shadow: 0 10px 25px rgba(37, 99, 235, 0.4);
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.1s;
    }

    button.secondary {
      background: #111827;
      color: #e5e7eb;
      box-shadow: none;
      border: 1px solid rgba(148, 163, 184, 0.5);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
    }

    .status-line {
      font-size: 12px;
      color: #9ca3af;
      margin-top: 6px;
      min-height: 32px;
    }

    .split-row {
      display: grid;
      grid-template-columns: 1.4fr 1fr;
      gap: 10px;
      margin-top: 8px;
      align-items: start;
    }

    .legend-box {
      font-size: 11px;
      color: #9ca3af;
      border-radius: 10px;
      border: 1px solid rgba(55, 65, 81, 0.8);
      padding: 6px 8px;
      background: rgba(15, 23, 42, 0.8);
    }
  </style>

  <!-- Three.js CDN，用于 3D 渲染 -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>
  <h1>Quadcopter 1D PID Simulator with 3D Model</h1>

  <div class="container">
    <!-- 左：3D 场景 + 角度曲线 -->
    <div class="panel">
      <div class="split-row">
        <div>
          <div class="plot-label">3D Quadcopter Attitude (pitch axis)</div>
          <canvas id="threeCanvas" width="480" height="300"></canvas>
        </div>
        <div>
          <div class="plot-label">Angle vs Time (deg)</div>
          <canvas id="angleCanvas" width="360" height="180"></canvas>
          <div class="small-row">
            <span>0 s</span>
            <span>Time →</span>
          </div>
        </div>
      </div>

      <div class="split-row" style="margin-top:14px;">
        <div>
          <div class="plot-label">Control Torque vs Time (a.u.)</div>
          <canvas id="torqueCanvas" width="480" height="140"></canvas>
        </div>
        <div class="legend-box">
          说明：<br/>
          • 仿真为单轴姿态（Pitch），但 3D 模型会真实绕横轴旋转。<br/>
          • 你可以用它直观感受 Kp / Ki / Kd 对“机体姿态”影响。<br/>
          • 若想扩展到 Roll/Yaw，只需在代码里多加两个角度状态。
        </div>
      </div>

      <div id="statusText" class="status-line">
        Ready. 调好参数后点击 <b>Start</b>。
      </div>
    </div>

    <!-- 右：控制面板 -->
    <div class="panel">
      <h2>PID & Dynamics Controls</h2>
      <div class="controls">

        <div class="slider-row">
          <span>Kp</span>
          <input type="range" id="kpSlider" min="0" max="10" step="0.1" value="3.0" />
          <span id="kpValue">3.0</span>
        </div>

        <div class="slider-row">
          <span>Ki</span>
          <input type="range" id="kiSlider" min="0" max="5" step="0.05" value="0.8" />
          <span id="kiValue">0.80</span>
        </div>

        <div class="slider-row">
          <span>Kd</span>
          <input type="range" id="kdSlider" min="0" max="1" step="0.01" value="0.06" />
          <span id="kdValue">0.06</span>
        </div>

        <div class="small-label">
          这组初始值 ≈ “稍偏稳”的调参。可以先从这里开始：<br/>
          Kp 决定响应快慢，Ki 消除残差，Kd 抑制振荡。
        </div>

        <hr style="border:none;border-top:1px solid rgba(55,65,81,0.9);margin:10px 0;"/>

        <div class="field-row">
          <span>Target angle (deg)</span>
          <input type="number" id="targetAngleInput" value="10" step="1" />
        </div>

        <div class="field-row">
          <span>Mass & inertia preset</span>
          <select id="massPreset">
            <option value="light">Light (race quad)</option>
            <option value="medium" selected>Medium</option>
            <option value="heavy">Heavy (cinelifter)</option>
          </select>
        </div>

        <div class="btn-row">
          <button id="startBtn">Start</button>
          <button id="pauseBtn" class="secondary">Pause</button>
          <button id="resetBtn" class="secondary">Reset</button>
        </div>

        <div class="small-label">
          动力学模型：<br/>
          I·dω/dt = torque − c·ω<br/>
          dθ/dt = ω<br/>
          并加入测量噪声 + 积分限幅。
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============ 基本工具 ============
    function deg2rad(d) { return d * Math.PI / 180; }
    function rad2deg(r) { return r * 180 / Math.PI; }
    function clamp(x, min, max) {
      return x < min ? min : (x > max ? max : x);
    }
    function randomNormal() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    // ============ 仿真状态 ============
    const sim = {
      theta: 0,      // 角度（rad）
      omega: 0,      // 角速度（rad/s）
      integErr: 0,
      prevErr: 0,
      target: deg2rad(10),
      I: 0.02,
      damping: 0.02,
      t: 0,
      dt: 0.016,     // ~60Hz
      running: false,
      historyLength: 8.0
    };

    const history = {
      time: [],
      angleDeg: [],
      torque: []
    };

    // ============ DOM ============
    const threeCanvas = document.getElementById("threeCanvas");
    const angleCanvas = document.getElementById("angleCanvas");
    const torqueCanvas = document.getElementById("torqueCanvas");
    const angleCtx = angleCanvas.getContext("2d");
    const torqueCtx = torqueCanvas.getContext("2d");

    const kpSlider = document.getElementById("kpSlider");
    const kiSlider = document.getElementById("kiSlider");
    const kdSlider = document.getElementById("kdSlider");
    const kpValueLabel = document.getElementById("kpValue");
    const kiValueLabel = document.getElementById("kiValue");
    const kdValueLabel = document.getElementById("kdValue");
    const targetAngleInput = document.getElementById("targetAngleInput");
    const massPresetSelect = document.getElementById("massPreset");

    const startBtn = document.getElementById("startBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const resetBtn = document.getElementById("resetBtn");
    const statusText = document.getElementById("statusText");

    // ============ Three.js 3D 场景 ============
    let scene, camera, renderer, quadGroup;

    function initThree() {
      const w = threeCanvas.width;
      const h = threeCanvas.height;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x020617);

      camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 100);
      camera.position.set(4, 3, 6);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, antialias: true });
      renderer.setSize(w, h);
      renderer.setPixelRatio(window.devicePixelRatio || 1);

      // 灯光
      const ambient = new THREE.AmbientLight(0xffffff, 0.45);
      scene.add(ambient);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
      dirLight.position.set(5, 8, 5);
      scene.add(dirLight);

      // 地面
      const groundGeo = new THREE.PlaneGeometry(20, 20);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x0b1120,
        metalness: 0.1,
        roughness: 0.9
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -1;
      scene.add(ground);

      // 机体组
      quadGroup = new THREE.Group();

      // 机身中心
      const bodyGeo = new THREE.BoxGeometry(0.7, 0.15, 0.7);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1f2937, metalness: 0.4, roughness: 0.5 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      quadGroup.add(body);

      // 十字臂
      const armGeo = new THREE.BoxGeometry(2.0, 0.08, 0.18);
      const armMat = new THREE.MeshStandardMaterial({ color: 0x334155, metalness: 0.3, roughness: 0.6 });
      const armX = new THREE.Mesh(armGeo, armMat);
      const armZ = new THREE.Mesh(armGeo, armMat);
      armZ.rotation.y = Math.PI / 2;
      quadGroup.add(armX);
      quadGroup.add(armZ);

      // 四个桨盘
      const propGeo = new THREE.CylinderGeometry(0.23, 0.23, 0.05, 24);
      const propMat1 = new THREE.MeshStandardMaterial({ color: 0x38bdf8, metalness: 0.7, roughness: 0.3 });
      const propMat2 = new THREE.MeshStandardMaterial({ color: 0xf97316, metalness: 0.7, roughness: 0.3 });

      const positions = [
        [ 1.0, 0.08,  1.0],
        [-1.0, 0.08,  1.0],
        [-1.0, 0.08, -1.0],
        [ 1.0, 0.08, -1.0],
      ];

      positions.forEach((p, idx) => {
        const mat = (idx % 2 === 0) ? propMat1 : propMat2;
        const prop = new THREE.Mesh(propGeo, mat);
        prop.rotation.x = Math.PI / 2;
        prop.position.set(p[0], p[1], p[2]);
        quadGroup.add(prop);
      });

      quadGroup.position.y = 0.2;
      scene.add(quadGroup);

      // 初始姿态
      quadGroup.rotation.set(0, 0, 0);
    }

    function renderThree() {
      // pitch 用 sim.theta（绕 X 轴）
      quadGroup.rotation.x = sim.theta;
      // 微微绕 Y 轴转，让视角更立体
      quadGroup.rotation.y = 0.3 * Math.sin(sim.t * 0.1);
      renderer.render(scene, camera);
    }

    // ============ 质量预设 ============
    function applyMassPreset() {
      const preset = massPresetSelect.value;
      if (preset === "light") {
        sim.I = 0.015;
        sim.damping = 0.015;
      } else if (preset === "medium") {
        sim.I = 0.02;
        sim.damping = 0.02;
      } else {
        sim.I = 0.035;
        sim.damping = 0.03;
      }
    }

    // ============ 仿真一步 ============
    function stepSimulation() {
      const dt = sim.dt;

      const Kp = parseFloat(kpSlider.value);
      const Ki = parseFloat(kiSlider.value);
      const Kd = parseFloat(kdSlider.value);
      const targetDeg = parseFloat(targetAngleInput.value) || 0;
      sim.target = deg2rad(targetDeg);

      // IMU 测量噪声
      const measTheta = sim.theta + deg2rad(0.05) * randomNormal();
      const measOmega = sim.omega + deg2rad(0.2) * randomNormal();

      const err = sim.target - measTheta;
      sim.integErr += err * dt;
      sim.integErr = clamp(sim.integErr, -1.0, 1.0);
      const derr = (err - sim.prevErr) / dt;
      sim.prevErr = err;

      // PID 输出 torque
      const torque = Kp * err + Ki * sim.integErr + Kd * derr;

      // 动力学：I·dω/dt = torque - c·ω
      const domega = (torque - sim.damping * sim.omega) / sim.I;
      sim.omega += domega * dt;
      sim.theta += sim.omega * dt;
      sim.t += dt;

      // 记录历史
      history.time.push(sim.t);
      history.angleDeg.push(rad2deg(sim.theta));
      history.torque.push(torque);
      trimHistory();

      drawAnglePlot();
      drawTorquePlot();
      renderThree();
      updateStatus(Kp, Ki, Kd, targetDeg);
    }

    function trimHistory() {
      const maxT = sim.historyLength;
      const tNow = sim.t;
      while (history.time.length > 0 && (tNow - history.time[0]) > maxT) {
        history.time.shift();
        history.angleDeg.shift();
        history.torque.shift();
      }
    }

    // ============ 2D 绘图 ============
    function clearCanvas(ctx, canvas) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function drawAnglePlot() {
      const ctx = angleCtx;
      const canvas = angleCanvas;
      clearCanvas(ctx, canvas);
      const w = canvas.width;
      const h = canvas.height;

      ctx.save();
      ctx.fillStyle = "#020617";
      ctx.fillRect(0, 0, w, h);

      ctx.strokeStyle = "rgba(148,163,184,0.2)";
      ctx.lineWidth = 1;
      for (let i = 1; i < 10; i++) {
        const x = (i / 10) * w;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }

      const times = history.time;
      if (times.length < 2) {
        ctx.restore();
        return;
      }
      const t0 = times[0];
      const t1 = times[times.length - 1];
      const tSpan = t1 - t0 || 1;

      const angles = history.angleDeg;
      const targetDeg = parseFloat(targetAngleInput.value) || 0;
      const minAngle = Math.min(...angles, targetDeg, 0) - 5;
      const maxAngle = Math.max(...angles, targetDeg, 0) + 5;
      const aSpan = maxAngle - minAngle || 1;

      // target line
      const yTarget = h - ((targetDeg - minAngle) / aSpan) * h;
      ctx.strokeStyle = "rgba(234,179,8,0.9)";
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(0, yTarget);
      ctx.lineTo(w, yTarget);
      ctx.stroke();
      ctx.setLineDash([]);

      // angle curve
      ctx.strokeStyle = "#38bdf8";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < times.length; i++) {
        const x = ((times[i] - t0) / tSpan) * w;
        const y = h - ((angles[i] - minAngle) / aSpan) * h;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      ctx.strokeStyle = "rgba(148,163,184,0.5)";
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

      ctx.restore();
    }

    function drawTorquePlot() {
      const ctx = torqueCtx;
      const canvas = torqueCanvas;
      clearCanvas(ctx, canvas);
      const w = canvas.width;
      const h = canvas.height;

      ctx.save();
      ctx.fillStyle = "#020617";
      ctx.fillRect(0, 0, w, h);

      const times = history.time;
      if (times.length < 2) {
        ctx.restore();
        return;
      }

      const t0 = times[0];
      const t1 = times[times.length - 1];
      const tSpan = t1 - t0 || 1;
      const torques = history.torque;
      const maxAbs = Math.max(...torques.map(Math.abs), 0.1);
      const span = 2 * maxAbs;

      const yZero = h * 0.5;
      ctx.strokeStyle = "rgba(148,163,184,0.4)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, yZero);
      ctx.lineTo(w, yZero);
      ctx.stroke();

      ctx.strokeStyle = "#f97316";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let i = 0; i < times.length; i++) {
        const x = ((times[i] - t0) / tSpan) * w;
        const y = h - ((torques[i] + maxAbs) / span) * h;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      ctx.strokeStyle = "rgba(148,163,184,0.5)";
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

      ctx.restore();
    }

    function updateStatus(Kp, Ki, Kd, targetDeg) {
      const angleNow = rad2deg(sim.theta).toFixed(2);
      const omegaNow = rad2deg(sim.omega).toFixed(2);
      statusText.innerHTML =
        `t = ${sim.t.toFixed(2)} s ｜ angle = ${angleNow}° ｜ rate = ${omegaNow}°/s<br>` +
        `Kp = ${Kp.toFixed(2)}, Ki = ${Ki.toFixed(2)}, Kd = ${Kd.toFixed(3)} ｜ target = ${targetDeg.toFixed(1)}°`;
    }

    // ============ 动画循环 ============
    function loop() {
      if (sim.running) {
        stepSimulation();
      } else {
        // 未运行时仍保持 3D 渲染（轻微转动）
        renderThree();
      }
      requestAnimationFrame(loop);
    }

    // ============ 事件 ============
    kpSlider.addEventListener("input", () => {
      kpValueLabel.textContent = parseFloat(kpSlider.value).toFixed(1);
    });
    kiSlider.addEventListener("input", () => {
      kiValueLabel.textContent = parseFloat(kiSlider.value).toFixed(2);
    });
    kdSlider.addEventListener("input", () => {
      kdValueLabel.textContent = parseFloat(kdSlider.value).toFixed(2);
    });

    massPresetSelect.addEventListener("change", () => {
      applyMassPreset();
    });

    startBtn.addEventListener("click", () => {
      sim.running = true;
    });
    pauseBtn.addEventListener("click", () => {
      sim.running = false;
    });
    resetBtn.addEventListener("click", () => {
      sim.theta = 0;
      sim.omega = 0;
      sim.integErr = 0;
      sim.prevErr = 0;
      sim.t = 0;
      history.time = [];
      history.angleDeg = [];
      history.torque = [];
      sim.running = false;
      drawAnglePlot();
      drawTorquePlot();
      renderThree();
      statusText.textContent = "Reset. 调好参数后再点 Start。";
    });

    // ============ 初始化 ============
    function init() {
      initThree();
      applyMassPreset();
      kpValueLabel.textContent = parseFloat(kpSlider.value).toFixed(1);
      kiValueLabel.textContent = parseFloat(kiSlider.value).toFixed(2);
      kdValueLabel.textContent = parseFloat(kdSlider.value).toFixed(2);
      drawAnglePlot();
      drawTorquePlot();
      renderThree();
      requestAnimationFrame(loop);
    }

    init();
  </script>
</body>
</html>

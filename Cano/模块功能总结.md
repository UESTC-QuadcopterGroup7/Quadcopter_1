PPM 

使用三个引脚 5v GND 信号线

PPM使用TIM2配置信号线

使用计时器输入捕获 以1us分辨率测量脉宽

要求长定时器周期 防止溢出



之所以使用TIM2 是因为TIM2 32位位宽 其他定时器都是16位

PPM一个周期 20ms完整帧

+ 通道脉宽 1~2ms
+ 同步脉宽 4ms

使用1MHz(1us)计数器时



一个PPM帧是20ms的原因 因为一帧里要包含所以通道数据 

通道1 1-2ms

通道2 1-2ms

通道3 1-2ms

...

通道8 1-2ms

同步脉冲 >=4ms 分割通道帧 标记下一帧开始

按照脉宽得到PPM值



volatile 修饰 表示不允许编译优化 即强行读存 而不能由编译器转存数值



PPM的8通道 按顺序放入数据

CH1 Roll 横滚(副翼)

CH2 Pitch 俯仰(升降)

CH3 Throttle 油门

CH4 Yaw 舵量

CH5 Aux1 模式切换

CH6 Aux2 其他辅助(飞行模式 云台等等)



PPM是固定帧长度协议 固定为20ms-22.5ms 即使只使用5-6个通道 空帧电平为低电平



代码解析

volatile PPM_Channels[PPM_MAX_CHANNELS]={0} 保存各个PPM通道的脉宽

volatile PPM_ChannelIndex=0 表示当前填写的第n个通道

volatile PPM_LastCapture=0 上一次捕获计数器的值 用来计算二次捕获的时间差(即脉宽)

GPIOA->MODER&=~(3U<<(0\*2)) 每个pin占2位 10复用功能 搭配使用PWM输入比较功能



在PPM_H中

定义Radiolink R8EF支持8通道

PPM_SYNC_US 3000 超过此值判定为同步帧

PPM_MIN_US 800 判定为有效脉宽最小值

PPM_MAX_US 2200 可判定为有效脉宽最大值



PPM_Channels[PPM_MAX_CHANNELS]

PPM_ChannelIndex

PPM_LastCapture



PPM_TIM2_IRQHandler() 

PPM_GetChannel() 获取某一通道值

PPM_FrameReady() 是否有新的PPM数据帧



PPM_New_FrameFlag



GPIOA->MODER&=~(3U<<(0*2))

GPIOA->MODER|=(2U<<(0*2)) 设置AF模式



GPIOA->AFR[0]&=~(0xF<<(0*4))

GPIOA->AFR[0]|=(0x1<<(0*4)) 使用TIM2_CH1

AFRL 控制PA0-PA7 AFRH 控制PA8-PA15 AF1对应TIM2/TIM5



TIM2->PSC=84-1 84/(PSC+1)=1MHz 配置TIM2输入捕获

TIM2->ARR=0xFFFFFFFF 32位计数器最大



TIM2->CCR1&=~TIM_CCMR1_CC1S 输入捕获CH1配置

TIM2->CCMR1|=TIM_CCMR1_CC1S_0 CC1S=01->IC1映射到TI1



TIM2->CCER&=~TIM_CCER_CC1P 上升沿捕获 

TIM2->CCER&=~TIM_CCER_CC1NP 非反向

配置捕获通道1的输入源

CCMR1的CC1S位决定CH1的输入/输出模式

先清零CC1S位 然后设置01

设置捕获沿 和 极性

清除CC1P 配置上升沿捕获

清除CC1NP 不使用互补极性(普通捕获)



TIM2->CCER|=TIM_CCER_CC1E 开启捕获 使能通道1输入捕获功能



TIM2->SR=0 清标志 开启中断 清除所有挂起的状态标志 防止残留中断立即触发

TIM2->DIER|=TIM_DIER_CC1IE 允许CH1捕获中断 

打开通道1捕获中断使能位 每次CCR1有新捕获就会进TIM2中断



TIM2->CR1|=TIM_CR1_CEN 使能TIM2



NVIC配置

NVIC_SetPriority(TIM2_IRQn,1) 设置中断优先级为1

NVIC_EnableIRQ(TIM2_IRQn) 使能TIM2中断通道



在中断函数中

PPM_TIM2_IRQHandler

if(TIM2->SR&TIM_SR_CC1IF) 捕获事件 中断触发事件

TIM2->SR&=~TIM_SR_CC1IF 请中断标志

now=TIM2->CCR1 从捕获寄存器CCR1读出当前捕获值

width=(now>=PPM_LastCapture)?(now-PPM_LastCapture):(0xFFFFFFFF-PPM_LastCapture+now)

计算本次上升沿与上次上升沿间的时间差width



PPM_LastCapture=now

if(width>PPM_SYNC_US) PPM_ChannelIndex=0 若此次width大于PPM_SYNC_US

认为刚刚经过PPM帧的同步间隔 把PPM_ChannelIndex归零 从通道0重新开始记录 新帧起点



else 保存通道脉宽

if(PPM_ChannelIndex<PPM_MAX_CHANNELS) 脉宽有效性判断

if(width>=PPM_MIN_US&&width<=PPM_MAX_US) PPM_Channels[PPM_ChannelIndex]=width



PPM_ChannelIndex++ width<=3ms 认为是某个通道的有效间隔 

如果当前通道索引小于最大通道数 先检查当前索引是否小于最大通道数 

在该范围内则将该值写到PPM_Channels[PPM_ChannelIndex]



使用PPM_ChannelIndex++ 表示下一个间隔属于下一个通道



if(PPM_ChannelIndex>=PPM_MAX_CHANNELS) PPM_NewFrameFlag=1 接收到8通道 说明收到完整一帧



PPM_GetChannel() 返回某通道脉宽

if(ch>=PPM_MAX_CHANNELS) return 1500

return PPM_Channels[ch] 

对外接口用于获取某个通道当前的脉宽值 如果ch越界 直接返回1500 通常表示中位值 防止非法访问

否则返回PPM_Channels[ch] 由volatile 表示调用时拿到的是最新的捕获值



PPM_FrameReady()

if(PPM_NewFrameFlag)

{PPM_NewFalgFlag=0 return 1}

return 0

